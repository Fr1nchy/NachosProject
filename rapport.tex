\documentclass[12pt]{report}
\usepackage[utf8]{inputenc}
\usepackage[french]{babel}
\usepackage[T1]{fontenc}
\usepackage{xcolor}
\usepackage{listings}
\renewcommand{\thechapter}{}

\addto\captionsfrench{
  \renewcommand\chaptername{}}
\title{Rapport de projet NachOS}
\author{
\'Equipe H\\\\
Mohd Thaqif ABDULLAH HASIM\\
Florian BARROIS\\
Cédric GARCIA\\
Hosseim NAHAL\\
Peio RIGAUX\\
}

\begin{document}
\maketitle


\chapter{Présentation de \color{red}notre nom badass\color{black}}

est un système d'exploitation basé sur le fonctionnement du système Unix. Il propose ainsi une version simplifiée des fonctionnalités de ce dernier, à savoir :
\begin{itemize}%[label=\textbullet,font=\color{black}]
\item Un système synchronisé d'entrées/sorties;
\item La gestion de plusieurs processus utilisateurs multithreadés \color{red}SI ON ARRIVE A FAIRE FONCTIONNER LES TESTS !\color{black}
\item Un système de fichiers permettant la manipulation de fichiers et la navigation à travers les répertoires \color{red}GERANT LES FICHIERS OUVERTS ??\color{black} et dont la taille des fichiers peut atteindre 112,5Ko.
\item La possibilité de communiquer en réseau...\color{red}DETAILS\color{black}

\end{itemize}


\chapter{Spécifications}
\section{Entrées/Sorties}

\textbf{char GetChar()}

Retourne le caractère lu sur l'entrée standard.\\


\textbf{void PutChar(char c)}

Écrit le caractère c sur la sortie standard.\\


\textbf{void GetString(char* s, int n)}
Récupère n caractères de la chaîne de caractères via l’entrée définie précédemment et les stocke dans la chaîne s stockée en paramètre. La lecture s’arrête lorsqu’un ‘\textbackslash n’ ou EOF est rencontré.
‘\textbackslash 0’ est stocké après le dernier caractère dans le tampon s.
‘\textbackslash 0’ est stocké à l’indice 0 du tampon quand la fin du fichier est détectée alors qu’aucun caractère n’a été lu.

\textbf{void PutString(const char s*)}

Parcourt la chaîne de caractères s et écrit caractère par caractère sur la sortie définie précédemment jusqu’à la rencontre du caractère ‘\textbackslash 0’ ou jusqu’à ce que MAX\_STRING\_SIZE soit atteinte. Le comportement est indéfini dans le cas où s ne contient pas de ‘\textbackslash 0’.

\textbf{void GetInt(int* n)}

Lit un entier depuis l'entrée standard, si la valeur n'est pas dans [$-2^{31}$; $2^{31}-1$] elle sera forcée à une de ces valeurs (la limite est de 16 caractères pour les entiers, au-delà les caractères ne seront pas comptés). SI un utilisateur entre le signe ‘-’ sans le faire suivre de chiffres, la valeur 0 est stockée.

\textbf{void PutInt(int n)}

Récupère la valeur de l’entrée définie précédemment puis l’écrit à l’adresse pointée par n. Le comportement est indéfini si la valeur n'est pas dans [$-2^{31}$; $2^{31}-1$].

\section{Threads, processus et synchronisation}
int do\_UserThreadCreate(int f, int arg)
Initialise un thread utilisateur, l’ajoute à la liste de threads et exécute la fonction f. Au niveau des arguments, f pointe vers la fonction que devra exécuter le thread et arg correspond au paramètre passé à la fonction f. Renvoie l’identifiant du thread.
int do\_UserThreadExit()
Enlève le thread courant de la liste des thread et termine son exécution.
static void StartUserThread(int f)
Initialise les registres MIPS et exécute la fonction f.
static int getIndexThreadById(int id)
Récupère l’index du thread ayant l’identifiant id dans la liste de threads.



\chapter{Tests utilisateur}
\section{Test sur la console :}
Pour l’instant, les tests fonctionnent à l’aide de l’entrée/sortie standard et les types de données pouvant être entrés sont testés manuellement (tentative de dépasser la taille que peut stocker un int pour getint.c par exemple).

%putchar.c : Programme donné dans le sujet de l’étape 2 permettant de tester l’appel système PutChar et d’afficher une série de caractères.
%putstring.c : Affiche la chaîne de caractères passé en paramètre de PutString sur la sortie. En cas de chaîne ayant une taille plus grande que MAX\_STRING\_SIZE, PutString n’envoie que les  MAX\_STRING\_SIZE premiers caractères.
getchar.c : Récupère un caractère sur l’entrée puis l’affiche, lui et les deux caractères le suivant dans l’ordre alphabétique.
getstring.c : Demande le nom de l’utilisateur (une chaîne de caractères) puis l’affiche précédé de « Bonjour Monsieur ».
 getint.c : Demande un entier à l’utilisateur, le borne afin de le faire rentrer dans un int, puis l’affiche (Ce test sert à la fois pour SynchGetInt() que pour SynchPutInt()).

\chapter{Implémentation}

\'Etape 2

char SynchGetChar() :
Fait appel à la fonction GetChar() de Console pour récupérer un caractère depuis l'entrée standard grâce un mécanisme d'interruption.

void SynchPutChar(const char ch) : 
Fait appel à la fonction PutChar() de Console pour écrire un caractère ch sur la sortie standard déclenchant une interruption.

void SynchGetString() : 
Effectue des appels à la fonction SynchGetChar() dans une boucle bornée par le nombre de caractères lus. Le caractère de fin de chaîne est concaténé à la chaîne obtenue.

void SynchPutString(const char s[]) : 
Fait appel à la fonction SynchPutChar() dans une boucle pour afficher des caractères sur la sortie standard. La boucle s'arrête lorsque le caractère de fin de chaîne est détecté ou lorsque la nombre maximum de caractères est atteint.  

void SynchGetInt(int *n) : 
Lit une chaîne de caractères depuis l'entrée standard grâce à la fonction SynchGetChar(). Le premier caractère est testé pour pouvoir considérer les nombres négatifs. Ensuite tant qu'un caractère dont le code ASCII correspond à un chiffre est détecté, ce chiffre est ajouté à la chaîne. La chaîne est terminée par le caractère de fin de chaîne et est stockée dans l’entier pointé par n.

void SynchPutInt(const int n) : 
Convertit l'entier n au format chaîne de caractères et l'affiche sur la sortie standard en appelant la fonction SynchPutString().
Étape 3

\chapter{Organisation du travail en équipe}
Répartition des tâches

%Cédric : Conception et implémentation, rédaction des tests.
%Florian : Conception et implémentation.
%Hosseim : Conception et implémentation.
%Thaqif : Implémentation, rédaction des tests.
Peio : Compte rendu et exécution des tests.
Les tâches assignées à chacun montrent l’organisation générale du groupe. Cependant, toute l’équipe se tient au courant de ce que chacun fait et peut ponctuellement travailler sur la même tâche (par exemple lors de la rédaction du premier compte rendu et de la compréhension du fonctionnement des piles de thread NachOS).


\chapter{Retour global sur le projet}

[à remplir à la fin]

\end{document}